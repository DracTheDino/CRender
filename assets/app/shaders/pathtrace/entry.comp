#version 440

layout (local_size_x = 8, local_size_y = 8) in;

/* Rendered Image */
layout (binding = 0, rgba8) uniform image2D rendered;

#define INF 1.0 / 0.0

/****************
Util Functions
*****************/

/*****************
Structs
******************/
struct Ray {
    vec3 o;
    vec3 d;
};

/* Uniform Structs */
struct Bvh
{
    vec4 front;// X-Z = Minimum X/Z, W = Leaf node
    vec4 back;// X-Z = Maximum X/Z, W = Next node (Or primitive ID) (int bits)
};
vec3 bvh_min(Bvh b) { return b.front.xyz; }
vec3 bvh_max(Bvh b) { return b.back.xyz; }
int bvh_next_node(Bvh b) { return floatBitsToInt(b.back.w); }
int bvh_primitive_id(Bvh b) { return floatBitsToInt(b.back.w); }
bool bvh_is_leaf(Bvh b) { return bool(b.front.w); }

struct Triangle
{
/*
v0 - X-Z = Vertex 0 XYZ, W = Unused
v1 - X-Z = Vertex 1 XYZ, W = Unused
v2 - X-Z = Vertex 2 XYZ, W = MaterialID (as int)
*/
    vec4 v0;
    vec4 v1;
    vec4 v2;
};
int triangle_mat_id(Triangle triangle) { return floatBitsToInt(triangle.v2.w); }

struct Material
{
/*
colour.w = Bit field
0x01 = Metal
0x02 = Smooth
0x04 = Glass
0x08 = Reserved
0x10 = Reserved
0x20 = If set, has texture, not set has albedo
colour.x = Colour R - If 0x20 set, texture ID (as int)
colour.y = Colour G - If 0x20 set, undefined
colour.z = Colour B - If 0x20 set, undefined

data.x = IOR
data.y = Roughness
data.z = Reflectiveness
data.w = Emission
*/
    vec4 colour;
    vec4 data;
};

int material_get_type(Material mat)
{
    return floatBitsToInt(mat.colour.w) & 0x07;
}
bool material_has_texture(Material mat) { return bool(floatBitsToInt(mat.colour.w) & 0x20); }
float material_ior (Material mat) { return mat.data.x; }
float material_roughness (Material mat) { return mat.data.y; }
float material_reflectiveness (Material mat) { return mat.data.z; }
float material_emission (Material mat) { return mat.data.w; }
float material_r (Material mat) { return mat.colour.x; }
float material_g (Material mat) { return mat.colour.y; }
float material_b (Material mat) { return mat.colour.z; }

struct IntersectionRecord
{
    int material_id;
    float distance;
    vec2 uv;
    vec3 normal;
    vec3 intersection_point;
};

layout (std140, binding = 0) uniform RenderData {
    ivec4 scene_information;// X-Y = Screen Resolution, Z = Max bounces, W = Camera Mode
    mat4 camera;// Camera MVP matrix (Current no model matrix)
    vec4 camera_data;// X = FOV, Y = Aspect correction
} render_data;

layout (std430, binding = 1) buffer BvhBuffer {
    Bvh nodes [];
} bvh;

layout (std140, binding = 2) buffer TriangleBuffer {
    Triangle triangles[];
} geometry;

layout (std140, binding = 2) buffer MaterialBuffer {
    Material materials[];
} mats;

layout (std140, binding = 3) buffer MaterialIndexBuffer {
    int indices [];
} material;

#define current_pixel gl_GlobalInvocationID

/**************************
Camera
***************************/
Ray camera_perspective(vec2 uv)
{
    uv *= 2.0f;
    uv -= 1.0f;
    uv.x *= render_data.camera_data.y;
    float w = 1.0 / tan(0.5f * render_data.camera_data.x);
    vec3 dir = (render_data.camera * vec4(uv, w, 0.0f)).xyz;

    return Ray(render_data.camera[3].xyz, normalize(dir));
}

/**************************
 Intersections
 **************************/
bool intersect_triangle(Ray r, vec3 v0, vec3 v1, vec3 v2)
{
    vec3 e0 = v1 - v0;// Edges / Normal
    vec3 e1 = v2 - v0;
    vec3 n = cross(e0, e1);
    float t = dot(v0 - r.o, n) / dot(r.d, n);// Plane Intersection
    vec3 p = r.o + t * r.d;
    vec3 p0 = p - v0;// Intersection Pos
    vec2 b = vec2(dot(p0, e0), dot(p0, e1));// p0 transform with basic vector
    mat2 a = mat2(dot(e1, e1), -dot(e0, e1), -dot(e0, e1), dot(e0, e0));// adjoint of 2x2 metric tensor
    float id = 1.0 / (a[0][0] * a[1][1] - a[0][1] * a[1][0]);// denominator of inverse 2x2 metric tensor
    vec2 uv = id * (a * b);// barycentric coordinate
    return 0 < uv.x && 0 < uv.y && uv.x + uv.y < 1;
}

bool intersect_triangle_record(Ray r, int prim_id, out IntersectionRecord record)
{
    vec3 v0 = geometry.triangles[prim_id].v0.xyz;
    vec3 v1 = geometry.triangles[prim_id].v1.xyz;
    vec3 v2 = geometry.triangles[prim_id].v2.xyz;

    vec3 e0 = v1 - v0;// Edges / Normal
    vec3 e1 = v2 - v0;
    vec3 n = cross(e0, e1);

    float t = dot(v0 - r.o, n) / dot(r.d, n);// Plane Intersection
    vec3 p = r.o + t * r.d;
    vec3 p0 = p - v0;// Intersection Pos

    vec2 b = vec2(dot(p0, e0), dot(p0, e1));// p0 transform with basic vector

    mat2 a = mat2(dot(e1, e1), -dot(e0, e1), -dot(e0, e1), dot(e0, e0));
    float id = 1.0 / (a[0][0] * a[1][1] - a[0][1] * a[1][0]);

    vec2 uv = id * (a * b);

    record.material_id = material.indices[prim_id];
    record.distance = t;
    record.uv = uv;
    record.normal = normalize(n);
    record.intersection_point = r.o + r.d * t;

    return 0 < uv.x && 0 < uv.y && uv.x + uv.y < 1;
}

bool intersect_aabb(vec3 bmin, vec3 bmax, vec3 o, vec3 id)
{
    float tx0 = (bmin.x - o.x) * id.x;
    float tx1 = (bmax.x - o.x) * id.x;

    float tmin = min(tx0, tx1);
    float tmax = max(tx0, tx1);

    float ty0 = (bmin.y - o.y) * id.y;
    float ty1 = (bmax.y - o.y) * id.y;

    tmin = max(tmin, min(ty0, ty1));
    tmax = min(tmax, max(ty0, ty1));

    float tz0 = (bmin.z - o.z) * id.z;
    float tz1 = (bmax.z - o.z) * id.z;

    tmin = max(tmin, min(tz0, tz1));
    tmax = min(tmax, max(tz0, tz1));

    return tmax >= tmin && tmin > 0.0;
}

bool intersect_bvh_record(Ray ray, out IntersectionRecord record)
{
    uint[64] stack;
    int stack_ptr = 0;

    stack[stack_ptr++] = ~0;
    uint stack_top = 0;

    vec3 inv_dir = 1.0 / ray.d;

    IntersectionRecord best = IntersectionRecord(-1, INF, vec2(0, 0), vec3(0, 0, 0), vec3(0, 0, 0));
    while (stack_top != ~0)
    {
        Bvh node = bvh.nodes[stack_top];
        vec3 min = bvh_min(node);
        vec3 max = bvh_max(node);

        if (intersect_aabb(min, max, ray.o, inv_dir))
        {
            if (bvh_is_leaf(node))
            {
                IntersectionRecord temp;
                if (intersect_triangle_record(ray, bvh_primitive_id(node), temp))
                    if (temp.distance < best.distance)
                        best = temp;

                stack_top = stack[--stack_ptr];
            }
            else
            {
                stack[stack_ptr++] = bvh_next_node(node) + 1;
                stack_top = bvh_next_node(node);
            }
        }
        else
        {
            stack_top = stack[--stack_ptr];
        }
    }
    return best.distance != INF;
}

bool intersect_bvh(Ray ray)
{
    uint[64] stack;
    int stack_ptr = 0;

    stack[stack_ptr++] = ~0;
    uint stack_top = 0;

    vec3 inv_dir = 1.0 / ray.d;
    while (stack_top != ~0)
    {
        Bvh node = bvh.nodes[stack_top];
        vec3 min = bvh_min(node);
        vec3 max = bvh_max(node);

        if (intersect_aabb(min, max, ray.o, inv_dir))
        {
            if (bvh_is_leaf(node))
            {
                Triangle at = geometry.triangles[bvh_primitive_id(node)];
                if (intersect_triangle(
                ray,
                at.v0.xyz,
                at.v1.xyz,
                at.v2.xyz))
                return true;
                stack_top = stack[--stack_ptr];
            }
            else
            {
                stack[stack_ptr++] = bvh_next_node(node) + 1;
                stack_top = bvh_next_node(node);
            }
        }
        else
        {
            stack_top = stack[--stack_ptr];
        }
    }
    return false;
}

void main()
{
    if (
    0 < current_pixel.x && current_pixel.x < render_data.scene_information.x &&
    0 < current_pixel.y && current_pixel.y < render_data.scene_information.y)
    {
        vec2 uv = vec2(current_pixel.xy) / vec2(render_data.scene_information.xy);
        uv += 0.0000001 * bvh.nodes[0].back.w;
        Ray ray = camera_perspective(uv);

        float t = 0.5 * (ray.d.y + 1.0);
        vec3 c = (1.0 - t) * vec3(1.0) + t * vec3(0.5, 0.7, 1.0);

        //        if (bvh.nodes.length() > 0 && intersect_aabb(
        //            bvh_min(bvh.nodes[7]),
        //            bvh_max(bvh.nodes[7]),
        //            ray.o,
        //            1.0 /ray.d))


        IntersectionRecord record;
        if (bvh.nodes.length() > 0 && intersect_bvh_record(ray, record))
//        if (bvh.nodes.length() > 0 && intersect_bvh(ray))
        {
            float depth = record.distance / 500.0;
            depth = min(max(depth, 0.0), 1.0);
            c = vec3(depth);
            //            c = vec3(0.2f, 0.3f, 0.8f);
            //            c = vec3(record.normal * 0.5 + 0.5);
            //            c = vec3(record.uv, 1.0f);
        }

        imageStore(rendered, ivec2(current_pixel), vec4(c, 1.0f));
    }
}
