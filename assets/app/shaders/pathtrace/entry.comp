#version 440

layout (local_size_x = 8, local_size_y = 8) in;

/* Rendered Image */
layout (binding = 0, rgba8) uniform image2D rendered;
layout (binding = 1, rgba32f) uniform image2D accumulation;
uniform uint current_frame;

#define INF 1.0 / 0.0

/****************
Random
*****************/
ivec2 image_size = imageSize(rendered);
uint rng_index = 0;

uint wang_hash(uint seed)
{
    seed = (seed ^ uint(61)) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

uint rng_idx = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * image_size.x;
uint rng_state = wang_hash(rng_idx) + current_frame;

uint rand_xorshift()
{
    rng_state ^= (rng_state << 13);
    rng_state ^= (rng_state >> 17);
    rng_state ^= (rng_state << 5);
    return rng_state;
}

float rand_1()
{
    return rand_xorshift() / 4294967296.0f;
}

vec2 rand_2()
{
    return vec2(rand_1(), rand_1());
}

vec3 rand_3()
{
    return vec3(rand_1(), rand_1(), rand_1());
}


/****************
Util Functions
*****************/
float component_max(vec3 v) {
    return max(max(v.x, v.y), v.z);
}

float component_min(vec3 v) {
    return max(max(v.x, v.y), v.z);
}

/*****************
Structs
******************/
struct Ray {
    vec3 o;
    vec3 d;
};

/* Uniform Structs */
struct Bvh
{
    vec4 front;// X-Z = Minimum X/Z, W = Leaf node
    vec4 back;// X-Z = Maximum X/Z, W = Next node (Or primitive ID) (int bits)
};
vec3 bvh_min(Bvh b) { return b.front.xyz; }
vec3 bvh_max(Bvh b) { return b.back.xyz; }
int bvh_next_node(Bvh b) { return floatBitsToInt(b.back.w); }
int bvh_primitive_id(Bvh b) { return floatBitsToInt(b.back.w); }
bool bvh_is_leaf(Bvh b) { return bool(b.front.w); }

struct Triangle
{
/*
v0 - X-Z = Vertex 0 XYZ, W = Unused
v1 - X-Z = Vertex 1 XYZ, W = Unused
v2 - X-Z = Vertex 2 XYZ, W = MaterialID (as int)
*/
    vec4 v0;
    vec4 v1;
    vec4 v2;
};
int triangle_mat_id(Triangle triangle) { return floatBitsToInt(triangle.v2.w); }

struct Material
{
/*
colour.w = Bit field
0x01 = Metal
0x02 = Smooth
0x04 = Glass
0x08 = Reserved
0x10 = Reserved
0x20 = If set, has texture, not set has albedo
colour.x = Colour R - If 0x20 set, texture ID (as int)
colour.y = Colour G - If 0x20 set, undefined
colour.z = Colour B - If 0x20 set, undefined

data.x = IOR
data.y = Roughness
data.z = Reflectiveness
data.w = Emission
*/
    vec4 colour;
    vec4 data;
};

int material_get_type(Material mat)
{
    return floatBitsToInt(mat.colour.w) & 0x07;
}
bool material_has_texture(Material mat) { return bool(floatBitsToInt(mat.colour.w) & 0x20); }
float material_ior (Material mat) { return mat.data.x; }
float material_roughness (Material mat) { return mat.data.y; }
float material_reflectiveness (Material mat) { return mat.data.z; }
float material_emission (Material mat) { return mat.data.w; }
float material_r (Material mat) { return mat.colour.x; }
float material_g (Material mat) { return mat.colour.y; }
float material_b (Material mat) { return mat.colour.z; }

struct IntersectionRecord
{
    int material_id;
    float distance;
    vec2 uv;
    vec3 normal;
    vec3 intersection_point;
};

layout (std140, binding = 0) uniform RenderData {
    ivec4 scene_information;// X-Y = Screen Resolution, Z = Max bounces, W = Camera Mode
    mat4 camera;// Camera MVP matrix (Current no model matrix)
    vec4 camera_data;// X = FOV, Y = Aspect correction
} render_data;

layout (std430, binding = 1) buffer BvhBuffer {
    Bvh nodes [];
} bvh;

layout (std140, binding = 2) buffer TriangleBuffer {
    Triangle triangles[];
} geometry;

layout (std140, binding = 2) buffer MaterialBuffer {
    Material materials[];
} mats;

layout (std140, binding = 3) buffer MaterialIndexBuffer {
    int indices [];
} material;

#define current_pixel gl_GlobalInvocationID

/**************************
Sampling
***************************/
vec3 sample_sphere(vec2 uv)
{
    float cos_theta = 2.0f * uv.x - 1.0f;
    float sin_theta = sqrt(1.0f - cos_theta * cos_theta);

    float phi = 2.0f * 3.1415f * uv.y;
    float sin_phi = sin(phi);
    float cos_phi = cos(phi);

    return vec3(sin_theta * cos_phi, cos_theta, sin_theta * sin_phi);
}

vec3 sample_hemp_cos(vec3 normal)
{
    vec3 sphere = sample_sphere(rand_2());
    return normal + sphere;
}

/**************************
Material
***************************/

/**************************
Camera
***************************/
Ray camera_perspective(vec2 uv)
{
    uv *= 2.0f;
    uv -= 1.0f;
    uv.x *= render_data.camera_data.y;
    float w = 1.0 / tan(0.5f * render_data.camera_data.x);
    vec3 dir = (render_data.camera * vec4(uv, w, 0.0f)).xyz;

    return Ray(render_data.camera[3].xyz, normalize(dir));
}

/**************************
 Intersections
 **************************/
bool intersect_triangle(Ray r, vec3 v0, vec3 v1, vec3 v2)
{
    vec3 e0 = v1 - v0;// Edges / Normal
    vec3 e1 = v2 - v0;
    vec3 n = cross(e0, e1);
    float t = dot(v0 - r.o, n) / dot(r.d, n);// Plane Intersection
    vec3 p = r.o + t * r.d;
    vec3 p0 = p - v0;// Intersection Pos
    vec2 b = vec2(dot(p0, e0), dot(p0, e1));// p0 transform with basic vector
    mat2 a = mat2(dot(e1, e1), -dot(e0, e1), -dot(e0, e1), dot(e0, e0));// adjoint of 2x2 metric tensor
    float id = 1.0 / (a[0][0] * a[1][1] - a[0][1] * a[1][0]);// denominator of inverse 2x2 metric tensor
    vec2 uv = id * (a * b);// barycentric coordinate
    return 0 < uv.x && 0 < uv.y && uv.x + uv.y < 1 && t > 0;
}

bool intersect_triangle1_record(Ray r, int prim_id, out IntersectionRecord record)
{
    vec3 v0 = geometry.triangles[prim_id].v0.xyz;
    vec3 v1 = geometry.triangles[prim_id].v1.xyz;
    vec3 v2 = geometry.triangles[prim_id].v2.xyz;

    vec3 e0 = v1 - v0;// Edges / Normal
    vec3 e1 = v2 - v0;
    vec3 n = cross(e0, e1);
    float t = dot(v0 - r.o, n) / dot(r.d, n);// Plane Intersection
    vec3 p = r.o + t * r.d;
    vec3 p0 = p - v0;// Intersection Pos
    vec2 b = vec2(dot(p0, e0), dot(p0, e1));// p0 transform with basic vector
    mat2 a = mat2(dot(e1, e1), -dot(e0, e1), -dot(e0, e1), dot(e0, e0));// adjoint of 2x2 metric tensor
    float id = 1.0 / (a[0][0] * a[1][1] - a[0][1] * a[1][0]);// denominator of inverse 2x2 metric tensor
    vec2 uv = id * (a * b);// barycentric coordinate

    record.material_id = material.indices[prim_id];
    record.distance = t;
    record.uv = uv;
    record.normal = normalize(n);
    record.intersection_point = r.o + r.d * t;

    return 0 < uv.x && 0 < uv.y && uv.x + uv.y < 1 && t > 0;
}

bool intersect_triangle_record(Ray r, int prim_id, out IntersectionRecord record)
{
    vec3 v0 = geometry.triangles[prim_id].v0.xyz;
    vec3 v1 = geometry.triangles[prim_id].v1.xyz;
    vec3 v2 = geometry.triangles[prim_id].v2.xyz;

    vec3 e0 = v1 - v0;// Edges / Normal
    vec3 e1 = v2 - v0;
    vec3 n = cross(e0, e1);

    float t = dot(v0 - r.o, n) / dot(r.d, n);// Plane Intersection
    vec3 p = r.o + t * r.d;
    vec3 p0 = p - v0;// Intersection Pos

    vec2 b = vec2(dot(p0, e0), dot(p0, e1));// p0 transform with basic vector

    mat2 a = mat2(dot(e1, e1), -dot(e0, e1), -dot(e0, e1), dot(e0, e0));
    float id = 1.0 / (a[0][0] * a[1][1] - a[0][1] * a[1][0]);

    vec2 uv = id * (a * b);

    record.material_id = material.indices[prim_id];
    record.distance = t;
    record.uv = uv;
    record.normal = normalize(n);
    record.intersection_point = r.o + r.d * t;

    return 0 < uv.x && 0 < uv.y && uv.x + uv.y < 1 && t > 0;
}

bool intersect_aabb(vec3 bmin, vec3 bmax, vec3 o, vec3 id)
{
    vec3 t0 = (bmin - o) * id;
    vec3 t1 = (bmax - o) * id;
    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);

    return component_max(tmin) <= component_min(tmax);
}

bool intersect_bvh_record(Ray ray, out IntersectionRecord record)
{
    uint[64] stack;
    int stack_ptr = 0;

    stack[stack_ptr++] = ~0;
    uint stack_top = 0;

    vec3 inv_dir = 1.0 / ray.d;

    IntersectionRecord best = IntersectionRecord(-1, INF, vec2(0, 0), vec3(0, 0, 0), vec3(0, 0, 0));
    while (stack_top != ~0)
    {
        Bvh node = bvh.nodes[stack_top];
        vec3 min = bvh_min(node);
        vec3 max = bvh_max(node);

        if (intersect_aabb(min, max, ray.o, inv_dir))
        {
            if (bvh_is_leaf(node))
            {
                IntersectionRecord temp;
                if (intersect_triangle1_record(ray, bvh_primitive_id(node), temp))
                    if (temp.distance < best.distance)
                        best = temp;

                stack_top = stack[--stack_ptr];
            }
            else
            {
                stack[stack_ptr++] = bvh_next_node(node) + 1;
                stack_top = bvh_next_node(node);
            }
        }
        else
        {
            stack_top = stack[--stack_ptr];
        }
    }
    record = best;
    return best.distance != INF;
}

bool intersect_bvh(Ray ray)
{
    uint[64] stack;
    int stack_ptr = 0;

    stack[stack_ptr++] = ~0;
    uint stack_top = 0;

    vec3 inv_dir = 1.0 / ray.d;
    while (stack_top != ~0)
    {
        Bvh node = bvh.nodes[stack_top];
        vec3 min = bvh_min(node);
        vec3 max = bvh_max(node);

        if (intersect_aabb(min, max, ray.o, inv_dir))
        {
            if (bvh_is_leaf(node))
            {
                Triangle at = geometry.triangles[bvh_primitive_id(node)];
                if (intersect_triangle(
                ray,
                at.v0.xyz,
                at.v1.xyz,
                at.v2.xyz))
                return true;
                stack_top = stack[--stack_ptr];
            }
            else
            {
                stack[stack_ptr++] = bvh_next_node(node) + 1;
                stack_top = bvh_next_node(node);
            }
        }
        else
        {
            stack_top = stack[--stack_ptr];
        }
    }
    return false;
}

vec3 path_trace(in Ray ray)
{
    vec3 throughput = vec3(1.0f, 1.0f, 1.0f);
    vec3 final = vec3(0.0f, 0.0f, 0.0f);

    int i = 0;
    for (; i < 5; i++)
    {
        IntersectionRecord record;
        if (bvh.nodes.length() > 0 && intersect_bvh_record(ray, record))
        {
            if (dot(record.normal, ray.d) > 0)
                record.normal *= -1;

            vec3 cos_hemp_dir = sample_hemp_cos(record.normal);

            ray.o = (ray.o + ray.d * record.distance) + record.normal * 0.0001f;
            ray.d = normalize(cos_hemp_dir);

            throughput *= vec3(0.2f);
            final += throughput;
        }
        else
        {
            float t = 0.5 * (ray.d.y + 1.0);
            final += throughput * (1.0 - t) * vec3(1.0) + t * vec3(0.5, 0.7, 1.0);
            break;
        }
    }

    return final;
}

void main()
{
    if (
    0 < current_pixel.x && current_pixel.x < render_data.scene_information.x &&
    0 < current_pixel.y && current_pixel.y < render_data.scene_information.y)
    {
        vec2 uv = vec2(current_pixel.xy) / vec2(render_data.scene_information.xy);
        vec3 colour = path_trace(camera_perspective(uv));
        vec4 accumulated = vec4(0.0f);

        if (current_frame != 0)
            accumulated = imageLoad(accumulation, ivec2(current_pixel));

        accumulated += vec4(colour, 1.0f);
        imageStore(accumulation, ivec2(current_pixel), accumulated);
        imageStore(rendered, ivec2(current_pixel), accumulated / float(current_frame + 1));
//        imageStore(rendered, ivec2(current_pixel), vec4(colour, 1.0f));
    }
}
